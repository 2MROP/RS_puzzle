<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Honeycomb Puzzle 4√ó4 ‚Äî No Gaps</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial,sans-serif;
  background:#0f0f0f;color:#fff;overflow:hidden;position:fixed;width:100%;height:100%;
}
#header{
  position:absolute;top:0;left:0;right:0;padding:12px 20px;z-index:10;
  display:flex;justify-content:space-between;align-items:center;
  background:rgba(0,0,0,.35);backdrop-filter:blur(8px);
}
#title,#timer{font-weight:700}
canvas{touch-action:none;cursor:grab}
canvas:active{cursor:grabbing}
#loading,#completionModal{
  position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:50;
  background:rgba(0,0,0,.8);backdrop-filter:blur(10px)
}
#completionModal{display:none}
.modal{
  background:#1f1f1f;border-radius:14px;padding:28px 24px;text-align:center;
  box-shadow:0 12px 40px rgba(0,0,0,.5)
}
.modal button{
  margin-top:14px;padding:10px 22px;border:0;border-radius:10px;cursor:pointer;
  background:#4ade80;color:#0b0b0b;font-weight:700
}
.hint-toggle{
  position:absolute;right:12px;bottom:12px;z-index:12;opacity:.7
}
.hint-toggle input{transform:scale(1.1);vertical-align:middle;margin-right:8px}
</style>
</head>
<body>

<div id="loading"><h3>Loading puzzle‚Ä¶</h3></div>

<div id="header">
  <div id="title">Honeycomb Puzzle 4√ó4</div>
  <div id="timer">00:00</div>
</div>

<canvas id="canvas"></canvas>

<label class="hint-toggle">
  <input id="toggleHints" type="checkbox" checked />
  Show placement guides
</label>

<div id="completionModal">
  <div class="modal">
    <h2>üêù Puzzle Completed!</h2>
    <p>Time: <span id="finalTime"></span></p>
    <button onclick="resetPuzzle()">Play Again</button>
  </div>
</div>

<script>
/* ================= CONFIG ================= */
const COLS = 4;          // 4 √ó 4 = 16 pieces
const ROWS = 4;
const SNAP = 30;
const IMG_PATH = "./assets/puzzle.jpg";

/* ================ STATE ================ */
let canvas, ctx, img;
let pw, ph, w, h, ox, oy;              // geometry
let pieces = [];                       // all tiles
let drag = null, dragOff = {x:0,y:0};  // dragging
let timerId = null, startTime = 0, done = false;

/* ============== INIT & IMAGE ============== */
window.addEventListener("load", () => {
  canvas = document.getElementById("canvas");
  ctx = canvas.getContext("2d");

  img = new Image();
  img.onload = () => { document.getElementById("loading").style.display = "none"; setup(); };
  img.src = IMG_PATH;

  document.getElementById("toggleHints").addEventListener("change", () => {});
});

function setup(){
  // Fit puzzle area to viewport while preserving image aspect ratio
  const headerH = 60, pad = 10;
  const availW = innerWidth - pad*2;
  const availH = innerHeight - headerH - pad*2;
  const imageAspect = img.width / img.height;

  if (availW / availH > imageAspect) {
    h = availH;
    w = h * imageAspect;
  } else {
    w = availW;
    h = w / imageAspect;
  }

  canvas.width = innerWidth;
  canvas.height = innerHeight;

  // --- KEY CORRECT MATH (Style A: pointy-top hex, staggered columns) ---
  // Total content size that hex grid occupies:
  //   width:  pw * (COLS + 0.5)   (because odd rows shift by +0.5 hex)
  //   height: ph * (ROWS*0.75 + 0.25)
  // So choose pw, ph so that content exactly equals (w, h)
  pw = w / (COLS + 0.5);
  ph = h / (ROWS * 0.75 + 0.25);

  ox = (innerWidth - w)/2;
  oy = (innerHeight - h)/2 + headerH/2;

  buildPieces();
  scatterPieces();
  attachEvents();
  startTimer();
  draw();
}

/* ============== PIECES ============== */
function buildPieces(){
  pieces = [];
  for (let r = 0; r < ROWS; r++){
    for (let c = 0; c < COLS; c++){
      const cx = ox + c*pw + (r%2 ? pw/2 : 0);
      const cy = oy + r*ph*0.75;

      // Precompute source rect mapping (PERFECT alignment!)
      const contentW = pw * (COLS + 0.5);
      const contentH = ph * (ROWS*0.75 + 0.25);
      const sx = ((c*pw + (r%2 ? pw/2 : 0)) / contentW) * img.width;
      const sy = ((r*ph*0.75) / contentH) * img.height;
      const sw = (pw / contentW) * img.width;
      const sh = (ph / contentH) * img.height;

      pieces.push({
        row:r, col:c,
        cx, cy,             // correct pos
        x:0,  y:0,          // current pos
        placed:false, z:r*COLS+c,
        sx, sy, sw, sh      // source mapping
      });
    }
  }
}

function scatterPieces(){
  const margin = 50;
  pieces.forEach(p => {
    p.x = Math.random()*(innerWidth - pw - margin*2) + margin;
    p.y = Math.random()*(innerHeight - ph - margin*2) + margin;
  });
}

/* ============== HEX SHAPE ============== */
function hexPath(ctx, x, y, w, h){
  const s = w/2, v = h/4; // pointy-top
  ctx.beginPath();
  ctx.moveTo(x+s, y);
  ctx.lineTo(x+w, y+v);
  ctx.lineTo(x+w, y+3*v);
  ctx.lineTo(x+s, y+h);
  ctx.lineTo(x,   y+3*v);
  ctx.lineTo(x,   y+v);
  ctx.closePath();
}

/* ============== INPUT ============== */
function attachEvents(){
  canvas.onmousedown = startDrag;
  canvas.onmousemove = moveDrag;
  canvas.onmouseup   = endDrag;
  canvas.ontouchstart= startDrag;
  canvas.ontouchmove = moveDrag;
  canvas.ontouchend  = endDrag;
}

function pointerPos(e){
  const r = canvas.getBoundingClientRect();
  const X = e.touches ? e.touches[0].clientX : e.clientX;
  const Y = e.touches ? e.touches[0].clientY : e.clientY;
  return { x: X - r.left, y: Y - r.top };
}

function startDrag(e){
  if (done) return;
  const p = pointerPos(e);
  pieces.sort((a,b)=>b.z-a.z).some(pc=>{
    if (p.x>=pc.x && p.x<=pc.x+pw && p.y>=pc.y && p.y<=pc.y+ph){
      drag = pc;
      dragOff.x = p.x - pc.x;
      dragOff.y = p.y - pc.y;
      pc.z = Math.max(...pieces.map(k=>k.z)) + 1;
      return true;
    }
  });
}

function moveDrag(e){
  if (!drag) return;
  const p = pointerPos(e);
  drag.x = p.x - dragOff.x;
  drag.y = p.y - dragOff.y;
}

function endDrag(){
  if (!drag) return;
  const dx = drag.x - drag.cx;
  const dy = drag.y - drag.cy;
  if (Math.hypot(dx,dy) < SNAP){
    drag.x = drag.cx;
    drag.y = drag.cy;
    drag.placed = true;
  }
  drag = null;
  checkCompleted();
}

/* ============== DRAW LOOP ============== */
function draw(){
  ctx.clearRect(0,0,innerWidth,innerHeight);

  // ---- Perfectly aligned faint background (tile-by-tile) ----
  if (document.getElementById("toggleHints").checked){
    ctx.globalAlpha = 0.18;
    for (const p of pieces){
      ctx.save();
      hexPath(ctx, p.cx, p.cy, pw, ph);
      ctx.clip();
      ctx.drawImage(img, p.sx, p.sy, p.sw, p.sh, p.cx, p.cy, pw, ph);
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  }

  // ---- Optional ghost outlines (at target positions) ----
  if (document.getElementById("toggleHints").checked){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1;
    for (const p of pieces){
      if (!p.placed){
        hexPath(ctx, p.cx, p.cy, pw, ph);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  // ---- Pieces ----
  pieces.sort((a,b)=>a.z-b.z);
  for (const p of pieces){
    ctx.save();
    hexPath(ctx, p.x, p.y, pw, ph);
    ctx.clip();
    ctx.drawImage(img, p.sx, p.sy, p.sw, p.sh, p.x, p.y, pw, ph);
    ctx.restore();

    // No borders on placed pieces (no gaps)
    if (!p.placed){
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 1.1;
      hexPath(ctx, p.x, p.y, pw, ph);
      ctx.stroke();
      ctx.restore();
    }
  }

  requestAnimationFrame(draw);
}

/* ============== TIMER / COMPLETE ============== */
function startTimer(){
  clearInterval(timerId);
  startTime = Date.now();
  updateTimer();
  timerId = setInterval(updateTimer, 1000);
}

function updateTimer(){
  if (done) return;
  const s = Math.floor((Date.now() - startTime)/1000);
  const mm = String(Math.floor(s/60)).padStart(2,"0");
  const ss = String(s%60).padStart(2,"0");
  document.getElementById("timer").textContent = `${mm}:${ss}`;
}

function checkCompleted(){
  if (pieces.every(p=>p.placed)){
    done = true;
    clearInterval(timerId);

    // Show the clean full image, no seams
    ctx.clearRect(0,0,innerWidth,innerHeight);
    ctx.drawImage(img, ox, oy, w, h);

    document.getElementById("finalTime").textContent =
      document.getElementById("timer").textContent;
    setTimeout(()=>document.getElementById("completionModal").style.display="flex",400);
  }
}

function resetPuzzle(){
  document.getElementById("completionModal").style.display = "none";
  done = false;
  for (const p of pieces){ p.placed = false; }
  scatterPieces();
  startTimer();
}

/* ============== RESIZE ============== */
let resizeT;
window.addEventListener("resize", () => {
  clearTimeout(resizeT);
  resizeT = setTimeout(()=>{ if(img && img.complete) setup(); }, 200);
});
</script>
</body>
</html>
